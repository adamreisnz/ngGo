{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","errors/invalidDataError.js","errors/invalidPositionError.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.js","board/layer/hoverLayer.js","board/layer/markupLayer.js","board/layer/scoreLayer.js","board/layer/shadowLayer.js","board/layer/stonesLayer.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js"],"names":["window","angular","undefined","constant","name","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","E","EMPTY","B","BLACK","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","PLAY","REPLAY","NONE","MOVE","SCORE","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","cellSize","scope","lastDrawHeight","drawHeight","$broadcast","drawWidth","instance","layer","playerElement","existingInstance","sizingElement","element","parent","Board","canvas","width","i","height","pixelRatio","layerOrder","layers","setContext","context","createLayerCanvas","size","setSize","toLowerCase","indexOf","split","setCutoff","attr","this","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","layerClass","toUpperCase","LayerClass","$injector","get","substr","left","right","bottom","prototype","cutoff","setSection","config","section","resized","side","changes","extend","show","coordinates","setMargin","theme","multiplier","parseInt","setTheme","y","value","remove","setAll","grid","removeAll","getAll","state","static","draw","xRight","yTop","top","yBot","noCellsVer","noCellsHor","round","absX","absY","s","board","getCellSize","r","clearRect","x","emptyValue","objects","push","toObject","newGrid","q","n","j","b","a","length","concat","setSubtract","empty","drawCell","$window","devicePixelRatio","clientHeight","ctx","lineWidth","radius","beginPath","x2","Math","cos","endAngle","PI","y2","sin","m","y1","angle","x1","dy","bx2","dx","by2","stroke","lines","shellLine","call","scale","stoneColor","thickness","color","offsetY","ceil","MarkupTypes","fromCharCode","invalid","floor","inverse","defaultTheme","path","BoardTheme","message","code","ngGo","error","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","info","defaultSize","komi","game","handicap","childNode","nodeMove","history","pop","newPosition","node","move","pass","validateMove","stones","markup","init","reload","jgf","clone","prop","copy","c","data","charAt","fromSgf","fromJgf","fromGib","fromJson","tree","nodes","getMoveNumber","fromMove","toMove","getMove","moveNodes","getMoveVariation","getPath","parseFloat","setKomi","defaultKomi","captures","StoneColor","W","p","defaultValue","obj","isMoveVariation","stop","splice","position","unset","hasStone","has","hasMarkup","type","GameNode","parentNode","rememberedPath","previousNode","executeNode","target","setMove","getPathToNode","children","Game","coords","baseObject","toColorConstant","jgfMove","jgfSetup","gameSetup","jgfMarkup","gameMarkup","convertCoordinates","l","text","turn","convertTurnFromJgf","properties","key","convertTurnToJgf","isMove","temp","conversionMap","gameNode","_typeof","appendChild","nextNode","toJgf","reset","branches","branch","no","newPath","captured","canCapture","captureGroup","enemyColor","BoardGrid","white","self","black","props","territorySet","candidateColor","boundaryColor","territoryReset","newState","adjacent","w","scoreState","WHITE_STONE","NEUTRAL","WHITE_CANDIDATE","BLACK_CANDIDATE","set","BLACK_STONE","points","score","application","charset","version","CA","FF","GM","SZ","PB","PW","base","blank","AP","CP","SO","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","BT","WT","N","C","CR","TR","SQ","MA","1","2","3","4","6","restrict","Player","attrs","$observe","mode","variationSiblings","broadcastEvent","originalEvent","mouseEvent","layerX","layerY","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","setLastMoveMarker","lastMoveMarker","setVariationMarkup","variationMarkup","modes","parseConfig","arrowKeysNavigation","arrowKeys","scrollWheelNavigation","scrollWheel","change","variationChildren","switchTool","tool","PlayerTools","restrictNodeStart","restrictNodeEnd","playerState","processPosition","gameState","undo","previousFork","previousComment","pathChanged","curGamePath","startMoveNum","endMoveNum","moveNum","toString","GameScorer","isLoaded","$parent","types","preventClickEvent","t","listener","on","$scope","arc","fill","_board","tx","ty","lineCap","strokeStyle","starRadius","starColor","starPoints","canvasTranslate","moveTo","lineTo","gridY","hover","object","objectClass","clear","restore","item","forEach","filter","add","_this","clearCell","StoneFaded","cap","ch","aCharLc","aChar","String","yt","yb","vertical","font","style","horizontal","textAlign","fillStyle","fillText","xr","closePath","rcos","bezierCurveTo","HAPPY","SAD","drawLabel","addColorStop","createRadialGradient","handler","stone","max","getAbsY","shadowColor","offsetX","blur","rank","match","players","player","result","regKomi","regDate","regResultMargin","regResultOther","escapeSgf","replace","output","values","sgf","flatComments","comments","comment","nodeName","parts","st","rootProperties","writeTree","parsingMap","extractRootProperties","subKey","jgfKey","jgfAliases","sgfAliases","parseMove","setup","parseSetup","parseTurn","parseMarkup","parseNodeName","record.application","parseBoard","parsePlayer","root","app","record","parseGame","sgfGames","dates","regProperty","regValues","parseSize","parseKomi","parseDate","AB","AW","AE","parseScore","PL","parseLabel","container","stack","PlayerModeCommon","mouseMove","PlayerModes","mouseOut","mouseDown","EDIT","SOLVE","mouseUp","mouse","dragStart","event","drag","start","deltaY","detail","wheelDelta","wheelDeltaY","axis","HORIZONTAL_AXIS","delta","next","previous","dragObject","broadcast","CLEAR","TEXT","NUMBER","PlayerModeEdit","modeEnter","mouseDrag","keyDown","click","lastY","setupToolColor","MarkupTools","markupTool","isValidMove","getTurn","markupLabels","addMarkup","markupLabel","isDrag","determineMarkupLabel","SetupTools","WHITE","label","SETUP","MARKUP","updateHoverMark","setStone","setMarkup","mark","statePreScoring","PlayerModeReplay","pathChange","toolSwitch","modeExit","variations","getNode","hasMoveVariations","showMoveVariations","hideMoveVariations","autoPlayPromise","autoPlayDelay","delay","PlayerModeSolve","solution","hideSolutionPaths","playerColor","solveAutoPlay","autoPlay","solveAutoPlayDelay","asOnBoard","solutionPaths","immediately","setSolveAutoPlay","setSolveAutoPlayDelay","problemSolved"],"mappings":"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","file":"ngGo.min.js","sourcesContent":["/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2017 Adam Reis (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '2.0.0',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10,\n  },\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1,\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy',\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve',\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup',\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34,\n});\n","/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service',\n])\n\n/**\n * Directive definition\n */\n.directive('board', function($window, Board) {\n\n  //Get pixel ratio\n  const pixelRatio = $window.devicePixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  function createLayerCanvas(name) {\n\n    //Create canvas element and get context\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  }\n\n  /**\n   * Helper to determine draw size\n   */\n  function determineDrawSize(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    let drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(\n        availableWidth / scope.Board.width,\n        availableHeight / scope.Board.height\n      );\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (\n      scope.lastDrawWidth !== drawWidth ||\n      scope.lastDrawHeight !== drawHeight\n    ) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  }\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&',\n    },\n\n    /**\n     * Linking function\n     */\n    link(scope, element, attrs) {\n\n      //Init vars\n      let i, context, layer, playerElement;\n      let existingInstance = true;\n      let sizingElement = element[0];\n      const parent = element.parent();\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', (event, width, height) => {\n\n        //First set the new dimensions on the canvas elements\n        let canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', () => {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', () => {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', (event, board) => {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //Get width and height\n        const width = sizingElement.clientWidth;\n        const height = sizingElement.clientHeight;\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, width, height)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas\n        //context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', size => {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') > -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', attr => {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', attr => {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', attr => {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    },\n  };\n});\n","\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    function Board(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    }\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (let l = 0; l < this.layerOrder.length; l++) {\n        const layer = this.layerOrder[l];\n        const layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        const LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false,\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /**************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      let changes = false;\n\n      //Check if there's a change\n      for (let side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else if (this.cutoff[side]) {\n            this.cutoff[side] = false;\n            changes = true;\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top &&\n        this.section.bottom === section.bottom &&\n        this.section.left === section.left &&\n        this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (let layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is\n        //handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Check if the board has a draw size\n     */\n    Board.prototype.hasDrawSize = function() {\n      return (this.drawWidth > 0 && this.drawHeight > 0);\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /**************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /**************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /**************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /**************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      let state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          let grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /**************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (let i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /**************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom,\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      let noCellsHor = this.width + this.margin;\n      let noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (let side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor(\n        (this.drawWidth - this.gridDrawWidth) / 2\n      );\n      this.drawMarginVer = Math.floor(\n        (this.drawHeight - this.gridDrawHeight) / 2\n      );\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      const offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      const offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      const offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      const offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  };\n});\n","\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(obj.x);\n    const y = this.board.getAbsY(obj.y);\n    const s = this.board.getCellSize();\n    const r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n","\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  function toObject(x, y, valueKey) {\n\n    //Create coordinates object\n    const obj = {x, y};\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  }\n\n  /**\n   * Constructor\n   */\n  function BoardGrid(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  }\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /**************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    let objects = [];\n\n    //Loop coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    let newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /**************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid.grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    let changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      throw new Error('Trying to compare grids of a different size');\n    }\n\n    //Loop all coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /**************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (let x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n});\n","\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  function setSubtract(a, b) {\n    const n = [];\n    let q;\n    for (let i = 0; i < a.length; i++) {\n      q = true;\n      for (let j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  }\n\n  /**\n   * Grid changes constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove)\n        .concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add)\n        .concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n","\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', function($window, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  function BoardLayer(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  }\n\n  /**************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /**************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      const pixelRatio = $window.devicePixelRatio || 1;\n      const width = this.context.canvas.clientWidth * pixelRatio;\n      const height = this.context.canvas.clientHeight * pixelRatio;\n      this.context.clearRect(0, 0, width, height);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n});\n","\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  const BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw() {\n      if (!this.board.hasDrawSize()) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    },\n  };\n\n  //Return\n  return BoardObject;\n});\n","\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    const x1 = x + radius * Math.cos(startAngle * Math.PI);\n    const y1 = y + radius * Math.sin(startAngle * Math.PI);\n    const x2 = x + radius * Math.cos(endAngle * Math.PI);\n    const y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    let m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    const c = this.factor * radius;\n    const dx = Math.sin(angle) * c;\n    const dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    const bx1 = x1 + dx;\n    const by1 = y1 - dy;\n    const bx2 = x2 + dx;\n    const by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  }\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    let startAngle = angle;\n    let endAngle = angle;\n\n    //Loop lines\n    for (let i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n","\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  let defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25,\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius(cellSize, scale = 1) {\n        return Math.round(Math.floor(cellSize / 2) * scale);\n      },\n\n      //Shell stones\n      shell: {\n        color(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75,\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5,\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75,\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2,\n          },\n        ],\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor() {\n          return '#000';\n        },\n        color(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        },\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1,\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        },\n      },\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85,\n      },\n\n      //Square\n      square: {\n        scale: 0.85,\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55,\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75,\n      },\n\n      //Last\n      last: {\n        scale: 0.7,\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85,\n      },\n\n      //Label\n      label: {\n        font: 'Arial',\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)',\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5,\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3,\n        },\n      },\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15, y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15, y: 15 },\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 },\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6},\n            ];\n          }\n\n          //No star points\n          return [];\n        },\n      },\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        },\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        },\n      },\n    },\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    function BoardTheme(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    }\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property, ...args) {\n\n      //Determine path to the property\n      const path = property.split('.');\n      let prop = this.theme;\n\n      //Loop path\n      for (let i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          throw new Error('Could not find theme property ' + property);\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      const path = property.split('.');\n      let prop = this.theme;\n\n      //Loop path\n      for (let i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n});\n","\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  function InvalidDataError(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  }\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n});\n","\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  function InvalidPositionError(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  }\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n});\n","\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service',\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /**************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    function validateInfo() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    }\n\n    /**************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    function nextNode(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node.rememberedPath;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    }\n\n    /**\n     * Navigate to the previous node\n     */\n    function previousNode() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    }\n\n    /**\n     * Navigate to the first node\n     */\n    function firstNode() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    }\n\n    /**\n     * Find the move index in the child nodes.\n     */\n    function findMoveIndexInChildNodes(x, y, color) {\n\n      //Only iterate when there are children\n      if (this.node.hasChildren()) {\n        for (let i = 0; i < this.node.children.length; ++i) {\n          const childNode = this.node.children[i];\n\n          //Only check if the child node is a move node\n          if (childNode.isMove()) {\n            const nodeMove = childNode.move;\n            if (nodeMove.x === x && nodeMove.y === y && nodeMove.color === color) {\n              return i;\n            }\n          }\n        }\n      }\n\n      //The move doesn't exist\n      return null;\n    }\n\n    /**************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    function initializeHistory() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    }\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    function pushPosition(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    }\n\n    /**\n     * Remove current position from stack\n     */\n    function popPosition() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    }\n\n    /**\n     * Replace the current position in the stack\n     */\n    function replacePosition(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    }\n\n    /**************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    function executeNode() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      let i;\n      let newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.isMove()) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    }\n\n    /**************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    function Game(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set(newPosition) {\n          this.history[this.history.length] = newPosition;\n        },\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    }\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /**************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create a new object and get properties\n      const clone = new Game();\n      const props = Object.getOwnPropertyNames(this);\n\n      //Deep copy all properties\n      for (let p = 0; p < props.length; p++) {\n        const prop = props[p];\n        clone[prop] = angular.copy(this[prop]);\n      }\n\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        let c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      let jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      let jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf,\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (let i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      let jgf = KifuBlank.jgf();\n      let props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (let p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /**************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get nodes array for currently remembered path\n     */\n    Game.prototype.getNodes = function() {\n\n      //Initialize node to process\n      let node = this.root;\n      let nodes = [node];\n\n      //Process children\n      while (node) {\n        node = node.getChild(node.rememberedPath);\n        if (node) {\n          nodes.push(node);\n        }\n      }\n\n      //Return nodes\n      return nodes;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNode = function(move) {\n      let nodes = this.getMoveNodes(move, move);\n      return nodes.length ? nodes[0] : null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Get all nodes for the current path\n      let nodes = this.getNodes();\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || nodes.length;\n\n      //Filter\n      return nodes.filter(function(node) {\n        if (node.isMove()) {\n          let move = node.getMoveNumber();\n          return (move >= fromMove && move <= toMove);\n        }\n        return false;\n      });\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      if (this.node) {\n        return this.node.getMoveNumber();\n      }\n      return 0;\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n      let moveNodes = this.getMoveNodes();\n      return moveNodes.length;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      let komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      let captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (let i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      let obj = this.info;\n      let key;\n\n      //Loop the properties\n      for (let p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          throw new Error('Game info property ' + key + ' is not an object');\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /**************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      let stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.config.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n      //Check all history?\n      else if (this.config.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (let i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      let captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.config.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.config.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      let captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /**************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      let tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.isMove()) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          let node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          let i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      let foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (let i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (let i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /**************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      let newPosition = this.validateMove(x, y, color);\n\n      //Check whether the move is in the existed child nodes\n      //If so, simply move to the existed node\n      const existedIndex = findMoveIndexInChildNodes.call(this, x, y, color);\n      if (existedIndex !== null) {\n\n        //Push the new position\n        pushPosition.call(this, newPosition);\n\n        //Remember the path\n        this.node.rememberedPath = existedIndex;\n\n        //Change the current node pointer\n        this.node = this.node.children[existedIndex];\n\n        //Advance the path\n        this.path.advance(existedIndex);\n        return true;\n      }\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      let node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color,\n        },\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      let i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      let newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      let node = new GameNode({\n        move: {\n          pass: true,\n          color: color,\n        },\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      let i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /**\n     * Undo the placed stones\n     */\n    Game.prototype.undo = function() {\n\n      //Validate if we can undo\n      if (!this.node.parent || this.node.hasChildren()) {\n        return false;\n      }\n\n      //Remove the node, set the pointer to its parent\n      const parentNode = this.node.parent;\n      this.node.remove();\n      this.node = parentNode;\n\n      //Reset the remembered path index if the index doesn't exist\n      if (typeof this.node.rememberedPath !== 'undefined') {\n        if (this.node.rememberedPath >= this.node.children.length) {\n          delete this.node.rememberedPath;\n        }\n      }\n\n      //Retreat the path\n      this.path.retreat();\n\n      //Pop the last position\n      popPosition.call(this);\n\n      //Valid operation\n      return true;\n    };\n\n    /**************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      let path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      let n = path.getMove();\n      for (let i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      let state = {\n        jgf: this.jgf,\n        path: this.path.clone(),\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  };\n});\n","\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  }\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  function coordinatesObject(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = Number(coords[0]);\n      baseObject.y = Number(coords[1]);\n    }\n    return baseObject;\n  }\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  function toStringColor(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  }\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  function toColorConstant(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  }\n\n  /**************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  function convertMoveToJgf(move) {\n\n    //Initialize JGF move object and determine color\n    let jgfMove = angular.copy(move);\n    let color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  }\n\n  /**\n   * Convert move from JGF format\n   */\n  function convertMoveFromJgf(move) {\n\n    //Prepare color, coordinates\n    let color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color),\n    });\n  }\n\n  /**\n   * Convert setup object to JGF format\n   */\n  function convertSetupToJgf(setup) {\n\n    //Initialize variables\n    let i, color;\n    let jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  }\n\n  /**\n   * Convert setup from JGF format\n   */\n  function convertSetupFromJgf(setup) {\n\n    //Initialize variables\n    let c, key, color;\n    let gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color,\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  }\n\n  /**\n   * Convert markup object to JGF format\n   */\n  function convertMarkupToJgf(markup) {\n\n    //Initialize variables\n    let i, type;\n    let jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  }\n\n  /**\n   * Convert markup from JGF format\n   */\n  function convertMarkupFromJgf(markup) {\n\n    //Initialize variables\n    let l, type;\n    let gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              let text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2],\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type,\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  }\n\n  /**\n   * Convert turn object to JGF format\n   */\n  function convertTurnToJgf(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Convert turn from JGF format\n   */\n  function convertTurnFromJgf(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  }\n\n  /**\n   * Conversions map\n   */\n  let conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf,\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf,\n    },\n  };\n\n  /**\n   * Constructor\n   */\n  function GameNode(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (let key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Get parent node\n   */\n  GameNode.prototype.getParent = function() {\n    return this.parent;\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    let moveVariations = 0;\n    for (let i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    let moveVariations = [];\n\n    //Loop child nodes\n    for (let i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /**\n   * Check if this is a move node\n   */\n  GameNode.prototype.isMove = function() {\n    return !!this.move;\n  };\n\n  /**\n   * Get move number\n   */\n  GameNode.prototype.getMoveNumber = function() {\n\n    //Move node?\n    if (this.isMove()) {\n      if (this.parent) {\n        return this.parent.getMoveNumber() + 1;\n      }\n      return 1;\n    }\n\n    //Use parent move number if we have one\n    if (this.parent) {\n      return this.parent.getMoveNumber();\n    }\n\n    //No parent\n    return 0;\n  };\n\n  /**************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    let i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    let i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      let temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    let i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      let temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /**************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    let variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        let properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (let key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            let prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    let node = {};\n    let properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (let key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        let prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      let variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (let i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        let variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n});\n","\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  function GamePath() {\n    this.reset();\n  }\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = i;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Decrement move\n    this.move--;\n\n    //Delete path choice\n    if (typeof this.path[this.move] !== 'undefined') {\n      const branch = this.path[this.move];\n      delete this.path[this.move];\n      if (branch > 0) {\n        this.branches--;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Do nothing if the move number is invalid\n    if (no < 0) {\n      return this;\n    }\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (let i in this.path) {\n        if (i >= no) {\n          const branch = this.path[i];\n          delete this.path[i];\n          if (branch > 0) {\n            this.branches--;\n          }\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (let i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    let newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  function findNodeName(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (let i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  }\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    let path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n","\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  function GamePosition(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  }\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /**************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    let color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    let captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    let color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /**************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /**************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    let newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n});\n","\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  function calcTotal() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  }\n\n  /**\n   * Constructor\n   */\n  function GameScore() {\n\n    //Get self\n    let self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  }\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    let props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (let i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    let b = this.black.total();\n    let w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n});\n","\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  let scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3,\n  };\n\n  /**\n   * Helper to set territory\n   */\n  function territorySet(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    let posColor = this.stones.get(x, y);\n    let origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  }\n\n  /**\n   * Helper to reset territory\n   */\n  function territoryReset(x, y) {\n\n    //Get original color from this position\n    let origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  }\n\n  /**\n   * Helper to determine score state\n   */\n  function determineScoreState() {\n\n    //Initialize vars\n    let change = true;\n    let curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1),\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * this.game scorer class\n   */\n  let GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate() {\n\n      //No game?\n      if (!this.game) {\n        throw new Error(\n          'No game loaded in game scorer, can\\'t calculate score.'\n        );\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      let komi = this.game.get('game.komi');\n      let captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      let x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark(x, y) {\n\n      //Get color of original position and state of the count position\n      let color = this.game.position.stones.get(x, y);\n      let state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    },\n  };\n\n  //Return\n  return GameScorer;\n});\n","\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  let blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8',\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black',\n        },\n        {\n          color: 'white',\n          name: 'White',\n        },\n      ],\n    },\n    board: {\n      width: 19,\n      height: 19,\n    },\n    tree: [],\n  };\n\n  /**\n   * Blank SGF\n   */\n  let blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White',\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  let KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf(base) {\n\n      //Initialize blank\n      let blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (let p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf(base) {\n\n      //Initialize blank\n      let blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (let p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n  };\n\n  //Return object\n  return KifuBlank;\n});\n","\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service',\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label',\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi',\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  let KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    },\n  };\n\n  //Return object\n  return KifuParser;\n});\n","/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive',\n])\n\n/**\n * Directive definition\n */\n.directive('player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    },\n\n    /**\n     * Linking function\n     */\n    link(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    },\n  };\n});\n","\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Provider definition\n */\n.provider('Player', function($windowProvider, PlayerModes, PlayerTools, MarkupTypes) {\n\n  //Get window instance\n  const $window = $windowProvider.$get();\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    $rootScope, $document, $timeout, Game, GameScorer, Board, PlayerTools\n  ) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    function processMouseEvent(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      let x = 0;\n      let y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent &&\n        typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent &&\n        typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent &&\n        typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent &&\n        typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= ($window.devicePixelRatio || 1);\n      y *= ($window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    }\n\n    /**\n     * Player class\n     */\n    const Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /**************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (const mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        let change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' &&\n          variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' &&\n          variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /**************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] &&\n          this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd,\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /**************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Undo the last position\n       */\n      undo() {\n        if (this.game) {\n          if (this.game.undo()) {\n            this.processPosition();\n            return true;\n          }\n          return false;\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        let node = this.game.getNode();\n        let path = this.game.getPath();\n        let position = this.game.getPosition();\n        let pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        const nodes = this.game.getMoveNodes(fromMove, toMove);\n        let move = fromMove;\n\n        //Loop nodes\n        nodes.forEach(node => {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++,\n          });\n        });\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /**\n       * Show move numbers in branch paths.\n       */\n      showBranchMoveNumbers() {\n\n        //Exit when there is no game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get the move move number range in which the variant branch is\n        const endMoveNum = this.game.getMove();\n        const curGamePath = this.game.clonePath();\n        const path = curGamePath.path;\n        let startMoveNum;\n        for (startMoveNum = 0; startMoveNum <= endMoveNum; ++startMoveNum) {\n          const rememberedPath = path[startMoveNum];\n          if (rememberedPath > 0) {\n            break;\n          }\n        }\n        startMoveNum += 1;\n        let moveNum = 1;\n\n        //Exit when the current game path doesn't contain a variant branch\n        if (startMoveNum > endMoveNum) {\n          return;\n        }\n\n        //Get nodes of the moves in the range\n        const nodes = this.game.getMoveNodes(startMoveNum, endMoveNum);\n\n        //Draw markups\n        nodes.forEach(node => {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: moveNum.toString(),\n          });\n          moveNum += 1;\n        });\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /**************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        let score = GameScorer.getScore();\n        let points = GameScorer.getPoints();\n        let captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /**************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /**************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          throw new Error('Listener is not a function: ' + listener);\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          const types = type.split(' ');\n          for (let t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Determine scope to use\n        const scope = $scope || $rootScope;\n        const self = this;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Wrap in timeout\n        $timeout(() => {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        });\n      },\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  };\n});\n","\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    const x = this.board.getAbsX(gridX);\n    const y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  }\n\n  /**\n   * Constructor\n   */\n  function GridLayer(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /**************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /**************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Get board properties\n    const {\n      width, height, theme,\n      drawMarginHor: tx, drawMarginVer: ty,\n    } = this.board;\n\n    //Get theme properties\n    const cellSize = this.board.getCellSize();\n    const lineWidth = theme.get('grid.lineWidth', cellSize);\n    const lineCap = theme.get('grid.lineCap');\n    const strokeStyle = theme.get('grid.lineColor');\n    const starRadius = theme.get('grid.star.radius', cellSize);\n    const starColor = theme.get('grid.star.color');\n    const starPoints = theme.get('grid.star.points', width, height);\n    const canvasTranslate = theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    let i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Draw star points\n    starPoints.forEach(point => {\n      drawStarPoint.call(this, point.x, point.y, starRadius, starColor);\n    });\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    const x = this.board.getAbsX(gridX);\n    const y = this.board.getAbsY(gridY);\n    const s = this.board.getCellSize();\n    const r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    const lineWidth = this.board.theme.get('grid.lineWidth', s);\n    const canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    const x = this.board.getAbsX(gridX);\n    const y = this.board.getAbsY(gridY);\n    const s = this.board.getCellSize();\n    const r = this.board.theme.get('stone.radius', s);\n\n    //Get board properties\n    const {theme, width, height} = this.board;\n\n    //Get theme properties\n    const lineWidth = theme.get('grid.lineWidth', s);\n    const strokeStyle = theme.get('grid.lineColor');\n    const starRadius = theme.get('grid.star.radius', s);\n    const starColor = theme.get('grid.star.color');\n    const canvasTranslate = theme.canvasTranslate(lineWidth);\n    const starPoints = theme.get('grid.star.points', width, height);\n\n    //Determine draw coordinates\n    const x1 = (gridX === 0) ? x : x - r;\n    const x2 = (gridX === width - 1) ? x : x + r;\n    const y1 = (gridY === 0) ? y : y - r;\n    const y2 = (gridY === height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    const starPoint = starPoints.find(point => {\n      return (point.x === gridX && point.y === gridY);\n    });\n\n    //Draw if found\n    if (starPoint) {\n      drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  function HoverLayer(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {x, y};\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      throw new Error('Unknown hover type ' + hover.type);\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x, y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y),\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    const hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    this.restore\n      .forEach((item, i) => {\n        if (item.x === x && item.y === y) {\n          this.board.add(item.layer, item.x, item.y, item.value);\n          this.restore.splice(i, 1);\n        }\n      });\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    const hover = this.grid.all('layer');\n\n    //Clear them\n    hover\n      .filter(item => item.objectClass && item.objectClass.clear)\n      .forEach(item => item.objectClass.clear.call(this, item.object));\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    this.restore.forEach(item => {\n      this.board.add(item.layer, item.x, item.y, item.value);\n    });\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Loop objects and draw them\n    this.grid.all('hover')\n      .filter(item => item.objectClass && item.objectClass.draw)\n      .forEach(item => item.objectClass.draw.call(this, item.object));\n  };\n\n  //Return\n  return HoverLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  function MarkupLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /**************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    const changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    changes.remove.forEach(change => Markup.clear.call(this, change));\n    changes.add.forEach(change => Markup.draw.call(this, change));\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Clear all markup items\n    this.grid.all('type').forEach(item => Markup.clear.call(this, item));\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /**************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Draw all markup\n    this.grid.all('type').forEach(item => Markup.draw.call(this, item));\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  function ScoreLayer(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /**************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    this.captures.forEach(cap => {\n      this.board.add('stones', cap.x, cap.y, cap.color);\n    });\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /**************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Draw captures first (removing stones from the stones layer)\n    this.captures.forEach(cap => {\n      this.board.remove('stones', cap.x, cap.y);\n      StoneFaded.draw.call(this, cap);\n    });\n\n    //Draw points on top of it\n    this.points.forEach(point => {\n      StoneMini.draw.call(this, point);\n    });\n  };\n\n  //Return\n  return ScoreLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  function ShadowLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false ||\n      (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context &&\n      this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    const cellSize = this.board.getCellSize();\n    const shadowSize = this.board.theme.get('shadow.size', cellSize);\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Draw all stones\n    this.grid.all('color').forEach(stone => StoneShadow.draw.call(this, stone));\n  };\n\n  //Return\n  return ShadowLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  function StonesLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /**************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    const changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff and draw added stuff\n    changes.remove.forEach(change => Stone.clear.call(this, change));\n    changes.add.forEach(change => Stone.draw.call(this, change));\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //Get all stones as objects\n    const stones = this.grid.all('color');\n\n    //Draw them\n    stones.forEach(stone => Stone.draw.call(this, stone));\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || !this.board.hasDrawSize()) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n});\n","\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  const kanji = [\n    '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', '', '', '', '',\n    '', '', '', '', '',\n  ];\n\n  //Character codes\n  const aChar = 'A'.charCodeAt(0);\n  const aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  const coordinates = {\n\n    //Kanji coordinates\n    kanji(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters(i) {\n\n      //Initialize\n      let ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf(i) {\n      let ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    },\n  };\n\n  /**\n   * Coordinates object\n   */\n  const Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || !this.board.hasDrawSize()) {\n        return;\n      }\n\n      //Get cell size\n      const cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      const xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      const xr = this.board.drawWidth - xl;\n      const yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      const yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      const theme = this.board.theme;\n      const fillStyle = theme.get('coordinates.color');\n      const vertical = {\n        font: theme.get('coordinates.vertical.font'),\n        size: theme.get('coordinates.vertical.size'),\n        style: theme.get('coordinates.vertical.style'),\n        inverse: theme.get('coordinates.vertical.inverse'),\n      };\n      const horizontal = {\n        font: theme.get('coordinates.horizontal.font'),\n        size: theme.get('coordinates.horizontal.size'),\n        style: theme.get('coordinates.horizontal.style'),\n        inverse: theme.get('coordinates.horizontal.inverse'),\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      let i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    },\n  };\n\n  //Return\n  return Coordinates;\n});\n","\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  const cosPi4 = Math.cos(Math.PI / 4);\n  const cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  function drawTriangle(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.triangle.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Square draw handler\n   */\n  function drawSquare(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.square.scale')\n    );\n\n    //Determine cos\n    const rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw circle handler\n   */\n  function drawCircle(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.circle.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw mark handler\n   */\n  function drawMark(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.mark.scale')\n    );\n\n    //Determine cos\n    const rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const lineCap = markup.lineCap || theme.get('markup.mark.lineCap');\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw select handler\n   */\n  function drawSelect(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.circle.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const fillStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Last move draw handler\n   */\n  function drawLast(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.last.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const fillStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw happy smiley handler\n   */\n  function drawHappySmiley(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.smiley.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const lineCap = markup.lineCap || theme.get('markup.smiley.lineCap');\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw sad smiley handler\n   */\n  function drawSadSmiley(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = Math.round(\n      theme.get('stone.radius', s, markup.scale) *\n      theme.get('markup.smiley.scale')\n    );\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = markup.lineWidth || theme.get('markup.lineWidth', s) || 1;\n    const lineCap = markup.lineCap || theme.get('markup.smiley.lineCap');\n    const strokeStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8,\n      y + r / 8 - 1,\n      x + r / 1.8,\n      y + r / 8 - 1,\n      x + r / 1.6,\n      y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw label\n   */\n  function drawLabel(markup) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(markup.x);\n    const y = this.board.getAbsY(markup.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n\n    //Determine radius\n    const r = theme.get('stone.radius', s, markup.scale);\n\n    //Get stone color\n    const stoneColor = this.board.get('stones', markup.x, markup.y) *\n      this.board.colorMultiplier;\n\n    //Get theme properties\n    const font = markup.font || theme.get('markup.label.font') || '';\n    const fillStyle = markup.color || theme.get('markup.color', stoneColor);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Clear label\n   */\n  function clearLabel(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  }\n\n  /**\n   * Markup class\n   */\n  const Markup = {\n\n    /**\n     * Draw\n     */\n    draw(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || !this.board.hasDrawSize()) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || !this.board.hasDrawSize()) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    },\n  };\n\n  //Return\n  return Markup;\n});\n","\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  let shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  function drawMono(stone) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(stone.x);\n    const y = this.board.getAbsY(stone.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n    const r = theme.get('stone.radius', s, stone.scale);\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    const color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    const lineWidth = theme.get('stone.mono.lineWidth', s) || 1;\n    const fillStyle = theme.get('stone.mono.color', color);\n    const strokeStyle = theme.get('stone.mono.lineColor', color);\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Glass stones\n   */\n  function drawGlass(stone) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(stone.x);\n    const y = this.board.getAbsY(stone.y);\n    const s = this.board.getCellSize();\n    const r = this.board.theme.get('stone.radius', s, stone.scale);\n\n    //Apply color multiplier\n    const color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    const canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Slate and shell stones\n   */\n  function drawSlateShell(stone) {\n\n    //Get coordinates and stone radius\n    const x = this.board.getAbsX(stone.x);\n    const y = this.board.getAbsY(stone.y);\n    const s = this.board.getCellSize();\n    const theme = this.board.theme;\n    const r = theme.get('stone.radius', s, stone.scale);\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    const color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    const shellTypes = theme.get('stone.shell.types');\n    const fillStyle = theme.get('stone.shell.color', color);\n    const strokeStyle = theme.get('stone.shell.stroke');\n    const canvasTranslate = theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      const type =\n        shellSeed %\n        (shellTypes.length + stone.x * this.board.width + stone.y) %\n        shellTypes.length;\n\n      //Determine random angle\n      const z = this.board.width * this.board.height +\n        stone.x * this.board.width + stone.y;\n      const angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Constructor\n   */\n  const Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || !this.board.hasDrawSize()) {\n        return;\n      }\n\n      //Determine style of stone\n      const style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          const handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false &&\n        this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || !this.board.hasDrawSize()) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false &&\n        this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    },\n  };\n\n  //Return\n  return Stone;\n});\n","\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', function(Stone) {\n\n  /**\n   * Class\n   */\n  const StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    },\n  };\n\n  //Return\n  return StoneFaded;\n});\n","\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', function(Stone) {\n\n  /**\n   * Class\n   */\n  const StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    },\n  };\n\n  //Return\n  return StoneMini;\n});\n","\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  const StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      const x = this.board.getAbsX(stone.x);\n      const y = this.board.getAbsY(stone.y);\n      const s = this.board.getCellSize();\n      const r = Math.max(\n        0, this.board.theme.get('stone.radius', s, stone.scale) - 0.5\n      );\n\n      //Get theme properties\n      const blur = this.board.theme.get('shadow.blur', s);\n      const offsetX = this.board.theme.get('shadow.offsetX', s);\n      const offsetY = this.board.theme.get('shadow.offsetY', s);\n      const shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear(stone) {\n\n      //NOTE: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't\n      //seem appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      const x = this.board.getAbsX(stone.x);\n      const y = this.board.getAbsY(stone.y);\n      const s = this.board.getCellSize();\n      const r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    },\n  };\n\n  //Return\n  return StoneShadow;\n});\n","\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  let regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  let regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  let regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  let regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  let regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  let regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  function parsePlayer(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    let color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    let player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase(),\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (let p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  }\n\n  /**\n   * Komi parser function\n   */\n  function parseKomi(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  }\n\n  /**\n   * Date parser function\n   */\n  function parseDate(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  }\n\n  /**\n   * Result parser function\n   */\n  function parseResult(jgf, match) {\n\n    //Winner color\n    let result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  }\n\n  /**\n   * Move parser function\n   */\n  function parseMove(jgf, node, match) {\n\n    //Determine player color\n    let color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n    node.move[color] = [Number(match[3]), Number(match[4])];\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse(gib, stringified) {\n\n      //Get new JGF object\n      let jgf = KifuBlank.jgf();\n\n      //Initialize\n      let match;\n      let container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      let node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  let jgfAliases = {};\n  for (let sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  }\n\n  /**************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  function escapeSgf(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  }\n\n  /**\n   * Helper to write an SGF group\n   */\n  function writeGroup(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (let i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  }\n\n  /**\n   * Move parser\n   */\n  function parseMove(move, output) {\n\n    //Determine and validate color\n    let color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    let coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  }\n\n  /**\n   * Setup parser\n   */\n  function parseSetup(setup, output) {\n\n    //Loop colors\n    for (let color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (let i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  }\n\n  /**\n   * Score parser\n   */\n  function parseScore(score, output) {\n\n    //Loop colors\n    for (let color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (let i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  }\n\n  /**\n   * Markup parser\n   */\n  function parseMarkup(markup, output) {\n\n    //Loop markup types\n    for (let type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        let i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  }\n\n  /**\n   * Turn parser\n   */\n  function parseTurn(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  }\n\n  /**\n   * Comments parser\n   */\n  function parseComments(comments, output) {\n\n    //Determine key\n    let key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    let flatComments = [];\n    for (let c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  }\n\n  /**\n   * Node name parser\n   */\n  function parseNodeName(nodeName, output) {\n    let key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  }\n\n  /**\n   * Game parser\n   */\n  function parseGame(game) {\n\n    //Loop SGF game definitions\n    for (let i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  }\n\n  /**\n   * Application parser\n   */\n  function parseApplication(application) {\n    let parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  }\n\n  /**\n   * Player instructions parser\n   */\n  function parsePlayer(player, rootProperties) {\n\n    //Variation handling\n    let st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  }\n\n  /**\n   * Board parser\n   */\n  function parseBoard(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  }\n\n  /**\n   * Players parser\n   */\n  function parsePlayers(players, rootProperties) {\n\n    //Loop players\n    for (let p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      let color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  }\n\n  /**\n   * Parse function to property mapper\n   */\n  let parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers,\n  };\n\n  /**************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  function writeTree(tree, output) {\n\n    //Loop nodes in the tree\n    for (let i = 0; i < tree.length; i++) {\n      let node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (let j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (let key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  }\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  function extractRootProperties(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (let subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        let jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        let value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        throw new Error('No moves tree in JGF object');\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      let output = {sgf: '(\\n;'};\n      let root = angular.copy(jgf);\n      let rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (let key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  let regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  let regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  let regProperty = /[A-Z]+/;\n  let regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  }\n\n  /**************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  function parseApp(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      let app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  }\n\n  /**\n   * SGF format parser\n   */\n  function parseSgfFormat() {\n    return;\n  }\n\n  /**\n   * Game type parser function\n   */\n  function parseGame(jgf, node, key, value) {\n    let game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  }\n\n  /**\n   * Move parser function\n   */\n  function parseMove(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  }\n\n  /**\n   * Comment parser function\n   */\n  function parseComment(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  }\n\n  /**\n   * Node name parser function\n   */\n  function parseNodeName(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  }\n\n  /**\n   * Board setup parser function\n   */\n  function parseSetup(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Scoring parser function\n   */\n  function parseScore(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: [],\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Turn parser function\n   */\n  function parseTurn(jgf, node, key, value) {\n    node.turn = value[0];\n  }\n\n  /**\n   * Label parser function\n   */\n  function parseLabel(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      let coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  }\n\n  /**\n   * Markup parser function\n   */\n  function parseMarkup(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Size parser function\n   */\n  function parseSize(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    let size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  }\n\n  /**\n   * Date parser function\n   */\n  function parseDate(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    let dates = value[0].split(',');\n    for (let d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  }\n\n  /**\n   * Komi parser function\n   */\n  function parseKomi(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  }\n\n  /**\n   * Variations handling parser function\n   */\n  function parseVariations(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    let st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  }\n\n  /**\n   * Player info parser function\n   */\n  function parsePlayer(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    let color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (let p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    let player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  }\n\n  /**\n   * Parsing function to property mapper\n   */\n  let parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel,\n  };\n\n  /**\n   * These properties need a node object\n   */\n  let needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB',\n  ];\n\n  /**************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  function setInfo(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    let node = jgf;\n    let key;\n\n    //Loop the position\n    for (let p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      let jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      let stack = [];\n      let container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      let node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      let sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (let i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        let properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (let j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          let key = regProperty.exec(properties[j])[0].toUpperCase();\n          let values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (let k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Run block\n */\n.run(function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT,\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT,\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n})\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  function dragObject(event) {\n\n    //Initialize drag object\n    let drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y,\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y,\n      },\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  }\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    let deltaX = 0;\n    let deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1,\n    },\n  });\n\n  /**\n   * Player mode definition\n   */\n  let PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      let delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y,\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    },\n  };\n\n  //Return\n  return PlayerMode;\n});\n","\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear',\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear',\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    let aChar = 'A'.charCodeAt(0);\n    let aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    function updateHoverMark(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK,\n              });\n            }\n          }\n\n          //Stone color tool;\n          //Add or overwrite stone if no stone present of the given color\n          else if (!this.game.hasStone(x, y, this.setupToolColor())) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.setupToolColor(),\n            });\n          }\n\n          //Stone present of same color? Can remove it if we're not dragging\n          else if (!isDrag) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK,\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel,\n              },\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool,\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to set markup\n     */\n    function setMarkup(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        let markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          let i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel,\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel,\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    }\n\n    /**\n     * Helper to set a stone\n     */\n    function setStone(x, y, isDrag) {\n\n      //Get the stone color\n      let color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    }\n\n    /**\n     * Find all markup labels in current position\n     */\n    function findAllMarkupLabels() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      let markup = this.game.position.markup.all('type');\n      for (let i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            let i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (let x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (let y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown(/*event, keyboardEvent*/) {\n\n        //TODO: tool switching via keyboard input\n        //Switch key code\n        // switch (keyboardEvent.keyCode) {\n        //\n        // }\n      },\n\n      /**\n       * Click handler\n       */\n      click(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag(event) {\n\n        //Initialize vars\n        let x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else if (this.statePreScoring) {\n          this.board.restoreState(this.statePreScoring);\n          delete this.statePreScoring;\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeEdit;\n  };\n});\n","\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    function updateHoverMark(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to show move variations on the board\n     */\n    function showMoveVariations(variations) {\n      for (let i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color'),\n        });\n      }\n    }\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    function hideMoveVariations(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    }\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    function drawMoveVariations(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      let node = this.game.getNode();\n      let variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        let self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else if (this.statePreScoring) {\n          this.board.restoreState(this.statePreScoring);\n          delete this.statePreScoring;\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeReplay;\n  };\n});\n","\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo',\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    function canMakeMove() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    }\n\n    /**\n     * Helper to update the hover mark\n     */\n    function updateHoverMark(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to show solution paths\n     */\n    function showSolutionPaths(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color'),\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color'),\n          });\n        }\n      }\n    }\n\n    /**\n     * Helper to hide solution paths\n     */\n    function hideSolutionPaths(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    }\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    function drawSolutionPaths(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      let node = this.game.getNode();\n      let variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        let children = [];\n        let self = this;\n        let i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          let i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          let node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeSolve;\n  };\n});\n"]}